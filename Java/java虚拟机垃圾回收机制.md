1. 代际GC是如何工作的？
　　垃圾回收是一个从Java堆中移除不在需要的java对象以释放内存的过程。几乎的所有的垃圾回收器是“代际”的，他们把堆分为不同的部分，或者不同的代。
2. 新生代(new generation)
　　大多数应用程序都有大量的生命周期短暂的对象，在一次的GC中分析程序的所有对象将是非常耗时的，因此将“短命”的对象分开处理以快速收集他们。所以所有的新对象将被放在新生代中。新生代又进一步分为：
　　* Eden(伊甸区)：所有新的对象将放在这里。当这个空间满了之后，次要GC(minor GC)将发生，所有任然被引用的对象将被提升到survivor space
　　* Survivor(幸存区)：幸存区根据不同的jvm有所不同，但是前提是相同的。每次新生代的GC都会增加幸存区中对象的年龄。当一个对象在minor GC中幸存的次数(默认值是有所不同，一般是15)足够过时，将会被提升到老年代.


3. 老年代(old generation)
　　任何从新生代存活下来的对象都会被提升到来年代。老年代通常比新生代大的多。在老年代中发生的GC叫做Full GC

4. 穿行GC
　　为单核计算机设计的，当GC发生的时候将会停止整个程序，它使用标记-清楚-整理的算法。

5. 并行GC
　　与穿行GC类似，不同的是他使用多线程执行GC，速度更快一些

6. 永久代
　　永久代是JVM存储元数据的地方。他在java8中被元数据所替代
　　元数据是用来描述数据的数据。
　　永久代不会触发垃圾回收，如果永久代满了会触发Full GC。
7. finallize()方法
　　finallize()方法是Java.Lang.Object中的方法，所有的对象都有该方法。默认的实现没有做任何事情，这个方法在这个对象没有被引用，垃圾回收器决定将他回收的时候调用。一个对象中，这个方法只能被垃圾回收器调用一次。

8. System.gc()和runtime.gc()
　　这两个方法提示JVM要进行垃圾回收。
每个Java程序都有一个Runtime类的实例，使用应用程序能够与其运行环境相连接。
　　在API中中Runtime类的gc方法是这样写的：
名称gc代表“垃圾回收器”。虚拟机根据需要在单独的线程中自动执行回收过程，甚至不用显示调用gc方法。
　　方法System.gc()是调用此方法的一种传统而便捷的方式

源码显示：
```java
//jdk1.8
public static void gc() {
        Runtime.getRuntime().gc();
    }
```
System.gc()方法是调用Runtime.getRuntime().gc()
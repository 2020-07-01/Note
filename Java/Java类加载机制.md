# 1. 类加载的简单过程：
　　类加载器简单就是用来加载类到Java虚拟机中。
　　Java虚拟机使用类的方式如下：Java源程序(.java文件)经过编译器编译为Java字节码文件(.class文件)。类加载器负责读取Java字节码文件，并转换为java.lang.Class类的一个实例。每个这样的实例用来表示一个Java类。通过此实例的newInstance()方法就可以创建出该类的一个对象。


# 2. 类加载的生命周期：
　　类加载的生命周期是从类被加载到内存开始，直到卸载出内存为止。
　　整个生命周期分为7个阶段：加载、验证、准备、解析、初始化、使用、卸载、


### 2.1. 加载
　　加载是类加载过程中的第一个阶段，整个阶段会在内存中生成一个代表该类的的Java.lang.Class对象，作为方法区这个类的各种数据的入口。
　　通过类的全限定名读取此类的二进制字节流(.class文件)加载到Java虚拟机内部，加载完成之后此二进制文件存储在运行时内存区的方法区之中，方法区中的数据格式由虚拟机自行定义。然后在内存中实例化一个Java.lang.Class对象实例(Java虚拟机规范并没有要求一定存储在堆区中，只是hotspot选择将class对象存储在方法区中，这个对象日后会作为方法区中该类的各种数据的访问入口。)

* 解释：
　　根据全限定名获取类的二进制字节流的方式有很多种：
  1.  从ZIP包中获取，
  2. 从网络中获取，例如Applet
  3. 运行时计算生成，这种场景使用最多的就是动态代理技术
  4. 由其他文件生成，比如jsp应用，由JSP文件生成对应的Class类
  5. 从数据库中进行获取


关于方法区的介绍：https://blog.csdn.net/qq_41357573/article/details/85875266


### 2.2. 验证
　　这一阶段的主要目的是为了确保Class文件的字节流中所包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

主要包括文件格式的验证、元数据的验证、字节码的验证、符号引用的验证
　
![Alt](https://segmentfault.com/img/bVtsfv)

### 2.3. 准备
准备阶段是正式为类变量分配内存并且设置类变量初始值的阶段，即在方法区中分配这些变量所使用的内存空间。
　　说明：这时候进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
　　这里所说的初始值指的是数据类型的零值

基本数据类型的零值

数据类型 | 零值 | 字节数 | 类型
---------|----------|---------|---------
 int | 0 | 4 | 整型
 long | 0L | 8 | 长整型
 short | (short)0 | 2 | 短整型
 char | '\u000' | 2 | 字符型
 byte | (byte)0 | 1 | 字节型
 boolean | false | 1 | 布尔类型
 float | 0.0f | 4 | 浮点型
 double | 0.0d | 8 | 双精度浮点型
 reference | null | 


　　如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量value会被初始化为ConstantValue属性所指的值。

例如：
public static final int value = 123;//此时将value值赋值为123

### 2.4. 解析
解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。

符号引用：符号引用是以一组符号来描述所引用的目标，符号是任何形式的自变量，只要使用时可以无歧义的定位到目标即可

直接引用：是直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。

直接引用和虚拟机实现的内存有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用不尽相同。


### 2.5. 初始化
初始化阶段是类加载过程的最后一步，此阶段真正执行类定义的Java程序代码。

初始化阶段是执行类构造器&lt;client&gt;方法的过程。

&lt;client&gt;方法是编译器自动收集类中的类变量赋值操作和静态语句中的语句合并而成。

* 在以下情况不会执行类的初始化：
    1. 通过类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化
    2. 定义对象数组，不会触发类的初始化


* 类初始化的时机：
    1. new 一个对象
    2. 调用类的静态成员和静态方法
    3. 通过反射对类进行调用
    4. 虚拟机启动，main()方法所在的类被提前初始化
    5. 初始化一个类，如果父类没有被初始化，则先初始化父类

# 3. 类加载器
虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到java虚拟机外部实现，以便让应用程序自己来决定如何去获取所需要的类。实现这个动作的代码模块称为类加载器。

类与类加载器关系：
类加载器虽然只用于类的加载动作，但是在Java程序中起到的作用远远不止于此。对于任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。

Java虚拟机提供了三种类加载器：
* 启动类加载器(Bootstrap ClassLoader)：
* 扩展类加载器(Extension ClassLoader):
* 应用程序类加载器(Application ClassLoader):一般也称为系统类加载器。他负责加载用户类路径上所指定的类库，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

![Alt](http://incdn1.b0.upaiyun.com/2017/06/d330251551f6de988239494ce2773095.png)


图中的这种层次关系被称为双亲委派模型。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。

这里类加载器之间的关系一般不会以继承的关系来实现，而是都用组合的关系来复用父加载器的代码。

双亲委派模型的工作过程：
　　如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求都会传入到顶层的启动类加载器中，只有当父类加载器犯规无法完成这加载请求时，子类加载器才会尝试自己去加载。

这样好处是不管那个类加载器加载类，最终都会委托给顶层的启动类加载器进行加载，这样保证了使用了不同类加载器最终得到了同一个Object对象。


类加载的时机:
　　一个类真正被加载的时机是在创建对象的时候，才会去执行类加载过程
　




 


























* 构造器：
在类中没有手动创建构造器的时候，系统才会为类提供一个默认的**无参构造器**，如果类中有手动创建构造器，则不会使用默认的无参构造器。

如果在子类的构造器第一行没有显示的调用父类的构造器，则默认调用父类的无参构造器，如果父类没有无参构造器，则必须显示调用父类的有参构造器。

* 当方法的参数变量名与类中的变量名相同时，则屏蔽类中的变量名，如果要在方法中使用类中的变量名则要进行特殊处理,使用this关键
字
 
4. 动态绑定和静态绑定

绑定指的是将方法的调用与方法的类关联起来

在覆盖一个方法时，子类的方法不能低于超类方法的可见性。



方法调用的过程:
首先查看对象的声明类型和方法名，此时可能存在多个方法名相同的方法
其次编译器查看调用方法时提供的参数类型，如果存在参数类型匹配的方法则进行调用,此过程称为重载解析。如果编译器没有找到相应的方法则报告一个错误。

如果是private方法、static方法、final方法则进行进行绑定，如果是其他方法则进行动态绑定

动态绑定过程:先杂此方法所在的实际类型中进行查找，如果未找到则在此类的超类中进行查找，依次进行

* final关键字：
final修改类则表示此类不能被继承，因此没有子类，其中类中的方法自动成为final而不包括域，例如String类型、基本类型的对象包装类
final修饰域则表示在构造对象之后此域不能再被改变
final修饰方法则表示子类不能覆盖这个方法

* 关于内联处理：
如果一个方法很短并且没有被覆盖，编译器则对他进行优化处理，这个过程成为内联，例如：e.getName()方法则被优化为直接访问e.name域

* 关于String中的散列码值
在String类中重写了hashcode方法，字符串的散列码是根据字符串的内容得出的，因此相同内容的字符串会有相同的散列码。

* 装箱和拆箱过程：
装箱和拆箱的过程是在编译期间执行的，而不是虚拟机执行，虚拟机只是执行这些编译后的子解码文件

java类型是值传递的，因此不能通过方法来改变数值参数的值，但是可以通过IntHoder类来改变参数的值。

接口中可以实现默认方法和静态方法
用default关键词修饰的方法为默认方法，默认方法不能重写object的方法，但是可以进行重载，这个接口的实现类会继承这个默认方法
静态方法是用static关键字修饰的方法，

如果一个类实现了两个接口，并且两个接口有相同的方法，则这个类会出现编译错误，否则要实现方法去选择两个方法中的一个。

如果一个类继承了一个超类和实现了一个接口，并且接口(静态方法)和父类中都有相同的方法，则超类优先
